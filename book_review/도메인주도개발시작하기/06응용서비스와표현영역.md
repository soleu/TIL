# **04.19.2023 Ch.06 응용 서비스와 표현 영역**
| 06.01 ~ 06.03 

사용자 → 표현 영역 → 응용 영역 → 도메인 영역

표현 영역 : 사용자의 요청을 해석 (실행 결과를 사용자에게 알맞은 형식으로 응답 → 사용자와의 상호작용)

응용 영역 : 실제 사용자가 원하는 기능을 제공 (기능 실행에 필요한 입력 값을 받고 실행 결과만 리턴)

응용 서비스 : 사용자(클라이언트)가 요청한 기능 실행

→ 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용
- ## **응용서비스의 역할**
1. **도메인 객체 간의 흐름을 제어**

public Result doSimeCreation(CreateSomeReq req) {

// validate data

validate(req);

// create Aggregate

SomeAgg newAgg = createSome(req);

// save aggregate to repository

someAggRepository.save(newAgg); // 내부의 도메인 로직은 도메인에서 해결. 응용 서비스는 도메인 객체간의 흐름 제어

// return result

return createSuccessResult(newAgg);

}

→ 응용 서비스가 복잡? ⇒ 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 수도 있음

단) 코드 품질에 악영향

1. 코드 응집성 저하

   : 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치 → 도메인 영역을 파악하게 위해 여러 영역을 분석해야 함 ( 리팩터링 - [산탄총 수술](https://en.wikipedia.org/wiki/Shotgun_surgery) )

1. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐

→ 결과적으로 코드 변경을 어렵게 만듬

Q. 이전에 로직을 응용 서비스에 두는게 좋은지? 아니면 도메인에 두면 좋은지? 에 대해 이야기를 나눈적이 있었는데, 지금은 어떻게 생각하는지? 바뀐점이 있다면?

도연님 : 도메인별로 역할이 딱 떨어지는 로직이라면 도메인 영역에 두는게 맞을 것 같음. 어떠한 로직이냐에 따라 응용서비스에 있어야하는 로직이 있을 것.

솔님 : 도메인에 두는 것은 좋으나, 객체를 수정해야하는 상황에서 이상적인 것 같음

보형님 : 도메인에 두는 것은 좋으나, 모든 개발자가 동일선상에서 차곡차곡 단계별로 해나갈때 가능할 것 같음
미소님 : 비즈니스 로직만 명확해진다면 나쁘지 않을 것 같음. 개발자들의 마인드에 따라 각기 달라질 것 같음(하기나름ㅎ)




`        `**2.트랜젝션 처리 담당**

: 도메인의 상태 변경을 트랜잭션으로 처리

도메인의 상태가 일괄적으로 처리해야 되거나 불가피하게 트랜젝션이 도메인 범위 이상으로 필요할 때, 응용서비스 레벨에서 트랜젝션 처리를 담당
- **응용서비스의 구현**

  -------------
  - 응용 서비스의 크기
    - 한 도메인과 관련된 기능을 한 클래스에 위치

→ 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점

→ 한 서비스 클래스의 크기가 커진다는 것이 단점 (연관성 없는 코드가 많아지게 됨)

`    `2. 구분되는 기능별로 서비스 클래스를 구현

→ 클래스 수는 많아 지지만 코드 품질을 일정 수준으로 유지하는데 도움이 됨

→ 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않음

Q. 두 방식 중 어떤 것을 선호하시는지? 해보시면서 느꼈던 불편했던 점은 있었는지?
미소님 : 단독서비스의 경우에는 1번처럼 처리. 볼륨이 커지게 된다면 고치게 될 것 같음
보형님 : 하나로 넣게되면 수정했을 때 찾기가 힘듬 → 화면 단위로 모두 잘게 쪼개게 됨. 관리가 편함
도연님 : 2번이 옳음. 중복되는 개념을 만들지 않아서 좋음. 레거시 코드의 경우 1번이 많음. 반대로 2번은 클래스단에서 서로의 정보를 주고 받는데 쉽지 않음(비동기 시에 어려움이 있음)
솔님 : 1번을 하게되는 이유는 볼륨이 작을 때 개발을 시작해서 그런 것 같음. 지속적인 리펙터링도 중요하다고 생각 




- ‘인터페이스가 필요할까?’
  - 1. 구현 클래스가 여러개인 경우
    : 구현 객체를 교체할 때 인터페이스를 유용하게 사용 가능
    (but, 응용 서비스가 여러개인 경우는 드물긴 함 → 응용 서비스 impl을 따로 만드는 건 좋지만은 않음)

    \*\* [service impl을 꼭 사용해야 하는가](https://jeonyoungho.github.io/posts/spring%EC%97%90%EC%84%9C-Service-ServiceImpl%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98/)


    2. TDD를 사용하게 될 경우

    : top-down - 응용서비스 인터페이스 이용해서 컨트롤러 구현 가능

    bottom-up - mocking을 통해 인터페이스 없이도 표현 영역 테스트 가능 (서비스 인터페이스 필요성 약화)

- 메서드 파라미터와 값 리턴

  :  응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터로 전달 받아야 함

- 메서드 파라미터

  // 파라미터로 전달받는 경우

  public class ChangePasswordService {

  `	`public void changePassword(String memberId, String curPw, String newPw) {

  	...

  `	`}

  }

  // 별도 데이터 클래스(DTO)로 전달 받는 경우

  public class ChangePasswordRequest {

  `	`private String memberId;

  `	`private String currentPassword;

  `	`private String newPassword;

  ... get method

  }

  public class ChangePasswordService {

  `	`public void changePassword(\*\*ChangePasswordRequest req\*\*) { // 필요한 값 전달 받음

  `		`Member member = findExistingMember (req.getMemberId());

  `		`member.changePassword(req.getCurrentPassword(), req.getNewPassword());

  `	`}

  }

- 값 리턴

  : 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높임

  애그리거트 자체 리턴 → 도메인 로직 실행을 응용 서비스 / 표현 영역 두 곳에서 가능하게 됨

  ([Order.xxx](http://Order.xxx) …) ⇒ 코드 응집도를 낮춤

- 표현 영역에 의존하지 않기

  : 응용 서비스의 파라미터 타입을 결정할 때, 표현 영역과 관련된 타입을 사용하면 안됨

  ex) HttpServletRequest , HttpSession

  → 응용 서비스만 단독으로 테스트하기 어려워짐

  → 표현 영역의 구현 변경시, 응용 서비스의 구현도 함께 번경

  → 표현 영역의 응집도 깨짐

- 트랜잭션 처리
  : 프레임 워크가 제공하는 트랜잭션 기능 적극 활용
