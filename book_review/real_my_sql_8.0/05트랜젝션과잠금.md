
## 1. 트랜젝션


: 작업의 완전성을 보장해 주는 것

→ 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

- 잠금 ↔ 트랜젝션

잠금 : 동시성을 제어하기 위한 기능

트랜젝션 : 데이터의 정합성을 보장하기 위한 기능

- InnoDB ↔ MyISAM

`INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3) ;`  // 1과 2는 insert 됨 (부분 업데이트 → 테이블 데이터의 정합성을 맞추는게 어려워짐)

`INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3) ;`  // 2과 2도 insert되지 않음 (전체 원상복구)

트랜젝션도 꼭 필요한 최소의 코드에만 적용하는 것이 좋음 (= 범위를 최소화)

## 2. MySQL 엔진의 잠금

- 잠금 종류
    - 스토리지 엔진 레벨

      : 스토리지 엔진 간 상호 영향을 미치지 않음

    - MySQL 엔진 레벨

      : 모든 스토리지 엔진에 영향

        - 글로벌 락

          : `FLUSH TABLES WITH READ LOCK`  명령

        - MySQL 제공 잠금 중 가장 범위가 큼 (영향 범위 : MySQL 서버 전체)
        - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때 까지 해당 문장은 대기 상태
        - v8.0부터는 백업 락이 도입 됨 → 한 세션에서 백업 락을 획득하면 모든 세션에서 스키마/인증 정보 변경 불가 (일반 테이블 데이터 변경은 허용)
            - 백업 도중 글로벌 락을 획득하면서 복제가 지연되는데, 도중 스키마 변경 등으로 정합성이 깨지는 것을 방지하기 위해 복제를 일시 중지
        - 테이블 락
            - 개별 테이블 단위로 설정되는 잠금 (명시적/묵시적 가능)
            - 묵시적 테이블 락 - MyISAM 이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
                - InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금 제공 (→ 단순 데이터 변경 쿼리로 테이블 락 X, 스키마 변경에만 적용)
        - 네임드 락
            - `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해잠금 설정 가능
            - **사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금**
            - 여러 클라이언트가 상호 동기화를 처리해야할 때 쉽게 해결 가능
            - 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용 (→ 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리 실행)
        - 메타데이터 락
            - 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금 (자동으로 제공)


## 3. InnoDB 스토리지 엔진 잠금

- 스토리지 엔진 내부에서 레코드 기반 잠금 방식 탑재
    - 장) MyISAM보다 훨씬 뛰어난 동시성 처리 제공 가능
    - 단) 이원화된 잠금 처리로 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 어려움
        - 최근 버전에서는 조회, 종료, 모니터링 방법 추가됨
- 레코드락, 레코드 사이의 간격을 잠그는 갭(GAP) 락 존재
- 종류
    - 레코드 락

      : 레코드 자체만을 잠그는 것.

      **레코드 자체가 아닌 인덱스의 레코드를 잠금**

      → 보조 인덱스를 이용한 변경 작업 : 넥스트 키 락, 갭 락 사용

      → 유니크 인덱스를 이용한 변경 작업 : 레코드만 락

      ⇒ 변경해야 할 레코드를 찾기 위해 **검색한 인덱스의 레코드를 모두 락**을 걸어야 함 (인덱스가 없다면 풀 스캔하면서 모두 락(충격적))

    - 갭 락

      : 레코드와 바로 인접한 레코드 사이의 간격만을 잠금

      레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어

    - 넥스트키 락

      : 레코드 락 + 갭락

      `REPEATABLE READ` 격리 수준 사용

      InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 역할

      but 데드락이나 다른 트랜잭션을 기다리게 만드는 일 빈번 (→ 바이너리 로크 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋음)

    - 자동 증가 락

      : 테이블에서 동시에 여러 레코드가 INSERT 되는 경우, 순서대로 증가하는 일련번호 값을 가지기 위해 사용

      내부적으로 `AUTO_INCREMENT락` 이라고 하는 테이블 수준의 잠금 사용


- 레코드 수준의 잠금
    - 단점 : 테이블 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음

## 4. MySQL의 격리 수준


: 여려 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

- 격리 수준 종류
    - READ UNCOMMITTED
        - 커밋 여부에 상관없이 다른 트랜잭션에서 접근/조회 가능
        - 빠르지만 데이터가 나타났다 사라졌다 할 수 있음 (정합성에 문제가 많음)
    - READ COMMITTED
        - 오라클 기본 격리 수준
        - 커밋 완료 시점에서만 조회 가능
        - non-repeatable read 문제로 정합성이 깨지고 어플리케이션 버그 발견 쉽지 않음, 금전문제에서는 사용 x
    - REPEATABLE READ
        - MySQL InnoDB 기본 격리 수준
        - 롤백을 위한 undo 공간 존재(MVCC방식 사용)
        - 자신보다 먼저 실행된 트랜젝션의 변경만 조회 가능
        - 언두 영역에 백업된 레코드(수정을 해서 백업을 위한 데이터)가 많아지면 서버 처리 성능이 떨어질 수 있음
    - SERIALIZABLE
        - 동시 처리 성능 떨어짐
        - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 접근 불가

뒤로갈수록 각 트랜잭션 간 **데이터 격리 정도가 높고, 동시 처리 성능 떨어짐**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/581eed3f-faf8-4d11-b04d-f9e892b09a3b/Untitled.png)

- dirty read : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- non-repreatable read : 하나의 트랜잭션 내에서 항상 같은 결과를 가져오지 못하는 부정합 문제 발생
- phantom read : 트랜잭션 시작 시점 데이터를 읽었을 때 존재하지 않았던 데이터가 다시 같은 조건으로 읽으면 존재함