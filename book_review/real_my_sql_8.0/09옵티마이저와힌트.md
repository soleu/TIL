- 옵티마이저 : 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업

### 쿼리 실행

- 실행 절차
    - **파싱(parsing) - SQL 파서,** 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리 (파스 트리)
    - **최적화 및 실행 계획 수립** - SQL 의 파싱정보 (파스 트리)를 확인하면서 어떤 테이블부터 읽고 인덱스를 이용해 테이블을 읽을지 선택
    - **실행 계획 실행** -결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

- 옵티마이저 종류
    - 방식 종류
        - **비용 기반 최적화** (Cost-based optimizer, CBO) - 비교적 최근
            - 퀴리를 처리하기 위해 여러 가지 가능한 방법을 만들고, 예측된 통계 정보를 통해 비용 산출을 하여 최소 비용 선택
        - **규칙 기반 최적화** (Rule-based optimizer, RBO) - 과거
            - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립


### 기본 데이터 처리

- 풀 테이블 스캔과 풀 인덱스 스캔 선택 요소
    - 풀 테이블 스캔
        - 테이블 레코드 건수가 작아서 풀테이블 스캔이 빠를 경우
        - WHERE 이나 ON 절에 인덱스를 이용할 수 있는 조건이 없는 경우
        - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
    - 리드 어헤드 : 연속된 데이터 페이지가 읽이면 미리 예측해서 디스크에서 읽어 버퍼 풀에 가져다 놓음

- 병렬 처리
    - v 8.0 ~ 의 기술
    - `innodb_parallel_read_threads` 라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경 가능
    - 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어듬, but 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있음

- ORDER BY 처리 (Using filesort)


    |  | **장점** | **단점** |
    | --- | --- | --- |
    | 인덱스 이용 | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름 | INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림
    인덱스 때문에 디스크 공간이 더 많이 필요
    인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요 |
    | Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때 단점이 장점으로 바뀜
    정렬해야 할 레코드가 많이 않으면 메모리에서 Filesort 가 처리되므로 충분히 빠름 | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림 |
    - 소트 버퍼 : 정렬이 필요한 경우만 할당. 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가. 쿼리 실행이 완료되면 반남
    > 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니므로 커넥션이 많을 수록, 정렬 작업이 많을 수록 소비되는 메모리 공간이 커짐
    - 정렬 알고리즘
        - 싱글 패스 - 레코드 전체를 소트 버퍼에 담을지 `<sort_key, row_id>`
        - 투 패스 - 정렬 기준 칼럼만 소트 버퍼에 담을지 `<sort_key, additional_fields>` /  `<sort_key, packed_additional_fields>`
    
    - 정렬 처리 방법
        
        
        | 정렬 처리 방법 | 실행 계획의 Extra 칼럼 내용 |
        | --- | --- |
        | 인덱스를 사용한 정렬 | 별도 표기 없음 |
        | 조인에서 드라이빙 테이블만 정렬 | “Using filesort” 메세지가 표시됨 |
        | 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | “Using temporary; Using filesort” 메시지 표시됨 |
        
        if (인덱스를 사용할 수 있다면)  인덱스 순서대로 읽어서 결과 반환
        
        else WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)

- GROUP BY 처리
- 내부 임시 테이블 활용


 ### 고급 최적화

- 옵티마이저 : 통계 정보 + 옵티마이저 옵션을 결합해 실행 계획 수립
- 옵티마이저 스위치 옵션
  : optimizer_switch 시스템 변수를 이용해서 제어
  - 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용
  특정 조인 최적화, 반환 방식 등을 설정 가능 (항상 성능이 좋아지는게 아니므로 세심한
  튜닝 필요)


### 조인 최적화 알고리즘

- 실행 계획을 최적화 시키는 알고리즘 2개
- Exhaustive 검색 알고리즘 (완전탐색)
  : MySQL 5.0과 그 이전 버전에서 사용되던 조인 최적화 기법
  FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적
  의 조합 1개를 찾는 방법
  테이블 20개 → 36628800개의 경우의 수 (⇒ 느림)
  
- Greedy 검색 알고리즘
  : MySQL 5.0부터 도입된 조인 최적화 기법
  1차로 생성된 조합 중 최소 비용의 실행 계획을 선정하여 다음 차수로 넘어감
  Exhaustive 알고리즘보다 시간이 많이 개선됨