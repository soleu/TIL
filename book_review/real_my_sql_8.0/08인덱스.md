## 1. 디스크 읽기 방식

- 읽기 방식 종류
    - 랜덤 I / O
      : 하드 디스크 드라이브의 원판을 돌려서 읽어야 할 데이터가 저장된 위치로 **디스크 헤더를 이동시킨 다음** 데이터를 읽는 것
      - 순차 I / O
      : 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽음

  → 디스크의 성능은 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하는가


어떻게 디스크 I/O를 줄이느냐가 관건

- 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브 (SSD)

HDD : 물리적 기계식 장치

SSD : 전자식 저장 매체 - D-ram보다는 느리지만 하드보단 빠름

순차 I/O에서는 SSD가 하드 보다 조금 빠르거나 거의 비슷한 성능

but 랜덤 I/O 에서 큰 성능 차이

데이터베이스 서버 : 랜덤을 통해 작은 데이터를 읽고 쓰는 작업 대부분
→ SSD :  DBMS용 스토리지에 최적

## 2. 인덱스


: 검색 결과를 빨리 가져오기 위해 칼럼의 값과 해당 레코드가 저장된 주소를 key-value로 삼아 인덱스를 만들어 두는 것 (칼럼의 값을 주어진 순서로 **미리 정렬해서 보관**)

- 장점
    - 조회시에 빠름
- 단점
    - 삽입/수정/삭제 시, 항상 값을 정렬해야하므로 느림

→ 인덱스를 추가할지 말지? 저장 속도 ↔ 조회 속도를 어떻게 조절할지

- 종류
    - 프라이머리 키
      : 레코드를 대표하는 칼럼 (not null)
      - 보조키

## 3. B-Tree 인덱스


: 데이터베이스 인덱싱 알고리즘 중 가장 일반적

- 원리

칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지

- 구조

트리 구조 최상위에 하나의 루트 노드가 존재하고, 그 하위에 자식 노드가 붙어 있는 상태

리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 갖고있음

MyISAM ↔ InnoDB 내부가 다름

- 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법이 다름
    - MYISAM : 세컨더리 인덱스가 물리적인 주소를 가짐
    - InnoDB : 프라이머리키를 주소처럼 사용 (인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더
- 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받음

- B-tree 인덱스를 통한 데이터 읽기
    - 인덱스 레인지 스캔

      : 인덱스의 접근 방법 중 가장 대표적인 접근 방식 (빠름)

    - 검색해야 할 인덱스의 범위가 결정 됐을 때 사용하는 방식
    - 루트노드에서 시작할 위치를 찾아 리포노드의 레코드만 순서대로 가져옴
    - 인덱스의 리프노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정 필요

  → 레코드 한 건 단위로 랜덤 I/O 발생

    1. 인덱스 탐색 (저장된 위치 찾음)
    2. 인덱스 스캔 (루트 → 리프)
    3. 데이터 파일에서 찾기

    - 인덱스 풀 스캔

      : 인덱스를 사용하여 인덱스의 처음부터 끝까지 모두 읽는 방식

  → 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번재 칼럼이 아닌 경우 인덱스 풀 스캔 방식 사용

  인덱스 크기가 테이블 크키보다 작으므로 효울적

    - 방식
        - 리프 노드에서 링크드 리스트 방식으로 처음부터 끝까지 스캔
    - 루스 인덱스 스캔

      : 듬성듬성하게 인덱스를 읽는 것 (중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리)

  → GROUP BY 또는 집합 함수 가운데 MIN() 또는 MAX() 함수에 대해 최적화를 하는 경우에 사용

  리프노드를 스캔하면서 불필요한 부분 스캡

    - 인덱스 스킵 스캔

      : 필요없는 것 넘기기 (WHERE 조건절의 검색을 위해 포괄적으로 사용 가능)

  루스 인덱스 : GroupBy 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용

- 다중 칼럼 인덱스 (= 복합 칼럼 인덱스)

  : 2개 이상의 칼럼을 포함하는 인덱스

    - 첫번째 칼럼 > 두번째 칼럼 순으로 의존 되어 정렬
    - 첫번째 칼럼이 동일할 때 두번째 칼럼을 바라보게 됨

  → 칼럼의 순서가 중요


- B-Tree 인덱스의 정렬 및 스캔 방향
    - 인덱스는 항상 오름차순으로 정렬
    - 최솟값부터 읽으면 오름차순, 최댓값부터 읽으면 내림차순

v.8.0에서 지원되는 내림차순 인덱스 → 정렬부터 반대로 하게 되므로 정순 정렬보다 28.9% 더 시간이 걸림

내부적으로

- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

이므로 속도 차이가 있을 수 밖에 없음

- 인덱스의 가용성과 효율성
    - 비교 조건의 종류와 효율성 (< > =)

  :필터링 - 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사 선택하는 과정

  **작업 범위를 결정하는 조건은 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다해서 성능을 높이지는 못함**

  → 조건절 순서 중요

    - 가용성

  복합 인덱스의 경우, 단일 인덱스보다 왼쪽 부분이 고정되지 않았기때문에 B-tree 인덱스의 효과를 얻을 수 없음


## 4. R-Tree 인덱스


: 공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스 (B-tree 보다 공간 개념 추가)

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스
- 공간 데이터의 연산 함수

- 용도

  : GPS 기준의 위도, 경도 좌표 저장에 주로 사용

위치 기반 검색에 사용

- **전문 검색 인덱스**
  : 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색시 사용

→ 이전의 인덱스 : 크지않은 데이터 또는 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘

- 방식

  : 본문에서 사용자가 검색하게 될 키워드 분석 → 빠른 검색용으로 사용할 수 있게 인덱스 구축

    - 어근 분석 알고리즘
        - 불용어 처리 : 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
        - 어근 분석 : 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
    - n-gram 알고리즘
        - 어근 분석 알고리즘의 언어의 차이와 난이도 를 보완한 단순한 키워드를 검색해내는 알고리즘
        - 방식

          본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법

          언어에 대한 이해와 준비작업 필요 없음


    `SELECT * FROM tb_test WHERE doc_body **LIKE %애플%**`


→ 풀 테이블 스캔으로 쿼리 처리

`SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINGST('애플' IN BOOLEAN MODE);`

→ 전문 검색 인덱스 (MATCH … AGIAINST) 사용

- **함수 기반 인덱스**

  칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축할 때 사용

    - 가상 칼럼 사용

    ```sql
    ALTER TABLE user
    	ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ',last_name)) **VIRTUAL**,
    	ADD INDEX ix_fullname (full_name);
    ```

  (VIRTUAL, STORED) 옵션으로 가상 칼럼을 만들어 인덱스로 지정 가능

    - 함수 이용 (ver 8.0 ~)

  → 가상 칼럼과 다르게 테이블의 구조를 변경하지 않고 함수로 직접 인덱스 생성

    ```sql
    CREATE TABLE user (
    	user_id BIGINT,
    	first_name VARCHAR(10),
    	last_name VARCHAR(10),
    	PRIMARY KEY (user_id),
    	**INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))**
    );
    ```


→ 동일한 구현 방법 사용 - 둘다 성능 차이 없음

- **멀티 밸류 인덱스**

  : 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

⇒ 정규화에 위배되는 형태 (JSON 배열 타입 필드에 대한 인덱스로 생겨남)

```sql
- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()
```

로 DB에 들어간 json 타입 검색 가능

- **클러스터링 인덱스**

  : 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
  > 프라이머리 키 값에 의해 레코드의 저장 위치 결정
  → 프라이머리 키 값이 변경될 시, 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것 의미

클러스터링 인덱스 == 클러스터링 테이블
> 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로 테이블 레코드의 저장 방식이라고 볼 수 있기 때문

- 장점
    - 프라이머리 키 기반의 검색이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
    - 레코드의 저장이나 프라이머리 키의 변경이 느림
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐

*** 사용시 주의 사항 P. 276 참조

- **유니크 인덱스**

  : 제약 조건, 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음

  (NULL의 경우는 특정한 값이 아니기 때문에 2개이상 저장될 수 있음)

    - 유니크 인덱스 vs 일반 세컨더리 인덱스
        - 읽기

          : 유니크하지 않는 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것

      → 읽어야할 레코드의 건수가 같다면 성능상의 차이는 미미

        - 쓰기

          : 유니크 인덱스 - 중복된 값이 있는지 체크 먼저 (락 걸고해서 데드락 빈번)

      >> 유니크하지 않는 세컨더리 인덱스의 쓰기보다 느림


- 유일성이 꼭 보장되어야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려

- **외래키**
    - InnoDB 스토리지 엔진에서만 생성 가능

  >> 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성

    - 특징
        - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금경합(잠금 대기)가 발생
        - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않음