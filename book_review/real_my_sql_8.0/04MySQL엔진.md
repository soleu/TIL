## ✏️ MySQL 서버

### 1️⃣ MySQL 엔진


: 요청된 SQL 문장을 분석하거나 최적화하는 등 **DBMS의 두뇌에 해당**하는 처리를 수행

- 내부 구조
    - 커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청 처리
    - SQL 파서 및 전처리기
    - 옵티마이저 : 쿼리의 최적화된 실행 도움


### 2️⃣ 스토리지 엔진


: 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분 담당

** 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능 내장

- 핸들러 요청(Handler)?

  : 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 각 스토리지 엔진에 쓰기 또는 읽기 요청을 보내는 것

    - 사용되는 API가 바로 핸들러 API (불펌 ㅈㅅ)

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/12ebf298-daf0-4c27-bf6c-bd13c79438a4/Untitled.png)

- 종류
    - InnoDB (MySQL 기본 제공)
    - MyISAM

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/e78c3c8e-db4e-4dd2-b193-088a2e6de524/Untitled.png)


### ✏️ MySQL 서버 - 스레딩 구조


: 커넥션 별로 포그라운드 스레드가 하나씩 생성 (1:1 관계)

- 종류
    - **포그라운드 스레드 (= 사용자 스레드)**

      : 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재

        - 특징

          **주로 각 클라이언트 사용자가 요청하는 쿼리 문장 처리**

          MySQL의 데이터 버퍼나 캐시로 부터 1차적으로 가져오고, 없으면 직접 디스크 데이터나 인덱스 파일 읽어서 작업 처리

            - MyISAM의 경우 쓰기 작업까지 포그라운드 스레드가 처리
            - Inno DB 테이블은 데이터 버퍼나 캐시까지만 포그라운드, 쓰기는 백그라운드
        - 프로세스

      클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 스레드는 다시 스레드 캐시로 되돌아감
      (이렇게 대기 중인 스레드가 설정 개수(thread_cache_size) 이상이면 그냥 종료됨)

    - **백그라운드 스레드**

      : 설정에 따라 개수가 가변적

        - Inno DB 경우
            - 인서트 버퍼 **병합** 스레드
            - 로그를 디스크로 **기록하는** 스레드 — 로그 스레드
            - InnoDB 버퍼 풀의 데이터를 디스크에 **기록하는** 스레드 — 쓰기 스레드
            - 데이터를 버퍼로 **읽어** 오는 스레드
            - 잠금이나 데드락을 **모니터링하는** 스레드
        - MyISAM의 경우

          포그라운드 스레드가 쓰기 작업까지 함꼐 처리

          → 데이터 변경의 경우 Inno DB에서는 기다리지않아도 되지만, MyISAM에서 일반적인 쿼리는 **쓰기 버퍼링 기능 사용**할 수 X


** 스레드 풀 모델 제외

## ✏️ 메모리 할당 및 사용 구조

- 메모리 공간 종류
    - 글로벌 메모리 영역 — **모든 스레드가 쉐어하는 영역**

      : MySQL 서버가 시작되면서 운영체제로부터 할당(각 운영체제의 메모리 할당 방식은 상당히 복잡)

    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
    - 로컬메모리 영역 (=세션 메모리 영역, 클라이언트 메모리 영역) — **독립 스레드 영역**
        - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 영역
        - **각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않음**
        - **각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있음**
            - 정렬 버퍼
            - 조인 버퍼
            - 바이너리 로그 캐시
            - 네트워크 버퍼

## ✏️ 플러그인, 컴포넌트 스토리지 엔진 모델


: 전용 플러그인 형태로 개발해서 요구사항에 맞게 사용 가능

- 전체가 아닌 스토리지 엔진의 처리 영역인 ‘데이터 읽기/쓰기’ 영역의 기능만 수행
    - 특징
        - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
        - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
        - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

  ⇒ 이런 단점을 보완하기 위해 MySQl 8.0 부터 **컴포넌트 아키텍처** 지원


** 핸들러

: MySQL이 스토리지 엔진을 조정하기 위해 핸들러라는 것을 사용

최소한 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야만 함

하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할줄 알아야 함

## ✏️ 쿼리 실행 구조

- 쿼리 파서

  : 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업

→ 쿼리 문장의 기본 문법 오류는 여기서 캐치

- 전처리기

  : 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인

→ 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 여기서 제거

- 옵티마이저 (DBMS의 두뇌)

  : 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정

- 실행 엔진 (중간관리자)

  : 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할

- 핸들러 (스토리지 엔진)

  : MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할

## ✏️ 쿼리 캐시


: SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환

but, 데이터가 변경되면 변경된 테이블과 관련된 캐시 모두 삭제 ⇒ **심각한 동시 처리 성능 저하 유발, 버그 생성**

⇒ MySQL 8.0 부터 완전히 제거

## ✏️ 스레드 풀


: 사용자의 요청을 처리하는 **스레드 개수를 줄여서** 동시 처리 되는 요청이 많다하더라도 MySQL 서버의 **CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게** 해서 **서버의 자원 소모를 줄이는 것**이 목적

→ 동시에 처리할 수 있는 스레드 개수를 줄여서 빨리 처리하게끔 (→ 스케줄링을 잘 하지 않으면 오히려 느려지기도 함)

⇒ CPU의 프로세서 친화도를 높이고, 불필요한 컨텍스트 스위치 줄여서 오버헤드를 낮출 수 있음

- CPU 코어의 개수 = thread_pool_size 를 맞추는게 프로세서 친화도 높음

** Percona Server - 스레드풀은 ‘선순위 큐와 후순위 큐’이용

→ 트랜잭션 내에 속한 SQL를 빨리 처리하여 잠금 경합을 낮춰 처리 성능 향상

## ✏️ 트랜잭션 지원 메타 데이터

- 메타 데이터 (데이터 딕셔너리) : 테이블의 구조 정보와 스토어드 프로그램 등의 정보

→ 8.0버전 부터 시스템 테이블(서버가 작동하는데 필요한 테이블) 모두 Inno DB에 저장

⇒ 트랜젝션 처리로 ‘완전한 성공 과 실패’만 있기 때문에 오류 유발 가능성 저하

- 메타데이터는 SDI(Serialized Dictionary Information) 파일 사용

---

## InnoDB 스토리지 엔진 아키텍처

- 특징
    - 거의 유일하게 **레코드 기반의 잠금 제공**
    - 높은 동시성 처리 가능
    - 안정적이며 성능 뛰어남

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/10475a96-a8cc-4ddf-b6d9-5a88cce017de/Untitled.png)


### 프라이머리 키에 의한 클러스터링 (..??)

: 모든 테이블은 기본적으로 **프라이머리 키**를 기준으로 클러스터링되어 저장

→ 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

⇒ 레인지 스캔 빠름

MyISAM 스토리지 엔진에서는 클러스터링 키 지원 X (프라이머리 키 : 유니크 키 제약을 가진 세컨더리 인덱스)

- 클러스터링 / 리플리케이션 / 샤딩

  ### 클러스터링

    - 여러 개의 **DB를 수평적인 구조로 구성**하여 Failover하는 시스템을 구축하는 방식동일한 DB 서버를 두 대를 묶고 active-active 상태로 운영하거나 active-stanby 상태로 운영한다. active-active 상태는 하나의 서버가 부담하던 부하를 2대의 서버에서 부담하기 때문에 cpu, 메모리 자원의 부하도 줄게 된다. 하지만, DB 스토리지를 2대의 서버가 공유하기 때문에 병목이 생길 수 있다. 이러한 단점을 보완하기 위해 active-stanby 상태로 두는데 장애 발생 시 failover를 통해 두 서버가 상호 전환하게 된다.노드가 죽으면 다른 노드가 살아있어 시스템을 장애없이 운영할 수 있다.동기 방식으로 노드들 간의 데이터를 동기화한다.여러 노드들 간에 데이터 동기화 시간이 필요하기 때문에 리플리케이션에 비해 쓰기 성능이 떨어진다.

  ### 리플리케이션

    - 여러 개의 DB를 master-slave 형태로 구축하고, master에 DML(Write-only)을 하고 slave에 복제(Read-only)하는 방식이다.비동기 방식으로 노드들 간의 데이터를 동기화한다.비동기 방식으로 데이터를 동기화하기 때문에 지연 시간이 거의 없다.노드들 간의 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할 수 있다.데이터 양이 많을 경우 데이터를 찾는데 오랜 시간이 걸린다.마스터 노드 장애 시 복구&대처가 까다롭다.

  ### 샤딩

  테이블을 특정 기준으로 나눠서 저장하고 검색하는 것을 의미한다. 데이터를 어떻게 분산시킬 것인지, 어떻게 읽을 것인지 결정하는 것이 중요하다. 분산시켜 저장하기 위한 기준이 Shard key이다.

    1) hard sharding-샤드의 수만큼 hash 함수를 사용해서 나온 결과에 따라 db 서버에 저장하는 방식이다.-db 서버가 추가될 경우 hash 함수가 변경되어야 하므로 기존에 저장되던 데이터의 정합성이 깨진다.2) dynamic sharding3) entity group-연관성 있는 엔티티를 한 샤드에 두는 방식이다.-같은 샤드에 있는 데이터를 조회할 때는 효과적이지만, 다른 샤드에 있는 데이터를 함께 조회할 때는 성능이 떨어진다.4) moduler sharding-PK를 모듈러 연산한 결과로 DB를 특정하는 방식-데이터량이 일정 수준에서 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 좋다.-DB를 추가 증설해야하는 상황에서 이미 적재된 데이터의 재정렬이 필요하다.5) range sharding-PK의 범위를 기준으로 DB를 특정하는 방식이다.-활성유저가 몰린 DB로 트래픽이나 데이터량이 몰릴 수 있다.

    - 참고 자료https://jordy-torvalds.tistory.com/94https://techblog.woowahan.com/2687/

### ✏️ 외래 키 지원


: 테이블 간 외래키 연결을 해줌

→ 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요, 잠금이 여러 테이블로 전파될 가능성 있음

`foreign_key_checks` 시스템 변수 off 로 설정하면 일시적으로 꺼짐

### ✏️  MVCC (Multi Version Concurrency Control)


: 목적 - 잠금을 사용하지 않는 일관된 읽기 제공

언두 로그 (Undo log)를 이용하여 구현

multi version - 하나의 레코드에 대해 여러 개의 버전이 동시에 제공

eg) update 되고 있는 레코드에 대해 select 하면 isolation level에 따라 읽어오는 값이 달라짐

→ 하나의 레코드에 대해 2개의 버전이 유지되고(언두영역에 저장), 필요에 따라 어느 데이터가 보여지는지 달라지는 구조(=MVCC)

### ✏️ 잠금 없는 일관된 읽기(Non-Locking Consistent Read)


: MVCC 기술을 이용해 잠금없이 읽기 가능

단, isolation level 이 `READ_UNCOMMITED` , `REPEATABLE_READ` , `READ_COMMITED` 일 경우 대기 없이 실행

### ✏️ 자동 데드락 감지


: 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리

- 데드락 감지 스레드를 이용 → 잠금 대기 그래프를 주기적으로 검사해 교착 상태에 빠진 트랜젝션 중 하나 강제 종료(언두 로그 레코드가 적은 트랜잭션부터 롤백의 대상 : ‘적게 가졌다’ → 롤백을 해도 언두 처리를 해야할 내용이 적다, 강제 롤백으로 인한 부하 덜 유발 )
- 동시처리 스레드가 많아지면 데드락 감지 스레드가 느려짐, 더 많은 CPU 소모

### ✏️ 자동화된 장애 복구


장애가 날 경우를 6단계로 복구하게 할 수 있음

### ✏️ 버퍼풀 ⭐️


: 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간

쓰기 작업을 지연시켜 **일괄 작업**으로 처리할 수 있게 해주는 버퍼 역할도 함

- 레코드 버퍼

  : 각 클라이언트 세션에서 테이블 레코드를 읽고 쓸 때 버퍼로 사용하는 공간

(전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블 개수에 따라서 결정)

- 버퍼풀의 구조

페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장

- LRU (Least Recently Used) 리스트 — 한번 읽어온 페이지 유지해서 디스크 읽기 최소화 목적
- 플러시(Flush) 리스트
- 프리(Free) 리스트 — 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록, 새로운 페이지 읽을 때 사용

의 세가지 자료 구조로 관리

- InnoDB가 데이터 찾는 과정 (대략)
    - 버퍼 풀에 있는지 검사
    - 없으면 디스크에서 버퍼풀에 적재, LRU 리스트에도 포인터 추가
    - LRU age 검사 && 자주 접근할 경우 어댑티브 해시 인덱스에 추가

- 버퍼풀 - 리두로그
    - 버퍼풀의 용도
        - 데이터 캐시 → 버퍼풀이 클수록 쿼리의 성능이 빨라짐
        - 버퍼링 → 리두로그와의 관계를 잘 설정해야 함

      ‘일괄 처리’ 기능을 하기 위해 INSERT, UPDATE,DELETE 명령으로 변경된 Dirty Page를 버퍼풀에 저장함

      리두로그를 사용하여 체크포인트 에이지를 계산하고 다 쓰면 일괄처리 진행

- 버퍼풀 플러시 — 더티 페이지를 디스크에 동기화
    - 플러시 리스트 플러시 — 더티 페이지의 디스크 동기화
    - LRU 리스트 플러시 — 사용 빈도 낮은 페이지를 체킹해서 프리 리스트로 옮김

- 리두로그 : 페이지의 변경된 내용만을 기록

→ 단) 더티 페이지를 디스크 파일로 플러시할 때 ***일부만 기록**된다면 페이지 내용을 복구하기 어려울 수 있음

** 파셜 페이지(Partial-page), 톤 페이지(Torn-page) : 하드웨어 오작동이나 시스템의 비정상 종료 등으로 발생하는 일부만 기록되는 현상

⇒ Double-Write 기법 활용

- ACID 중 영속성(Durable)과 밀접
    - 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안정장치
    - 데이터 변경 내용을 로그로 먼저 기록하기 때문에 가능
        - MySQL 8.0부터 리두 로그 비활성화 가능 → 데이터 적재 시간 단축

- 언두로그 : DML(INSERT, UPDATE, DELETE)로 변경되기 이전 백업 데이터
    - 트랜잭션 보장

  롤백시 이전 버전 데이터 복구

    - 격리 수준 보장

  다른 커넥션에서 데이터 조회시 트랜잭션 격리 수준에 맞게 언두 로그 데이터 반환


**  활성 상태의 트랜젝션이 장시간 유지되는 것은 성능상 좋지 않음 → 주기적 모니터링 중요

- 체인지 버퍼 : 인덱스를 업데이트하기 위해 랜덤하게 디스크를 읽는 작업을 위한 임시 메모리 공간

** 중복 여부를 체크해야하는 유니크 인덱스의 경우에는 사용 불가

- 체인지 버퍼 머지 스레드(백그라운드)를 사용하여 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각 병합

- 어댑티브 해시 인덱스

  : 사용자가 직접 생성하는 인덱스가 아닌 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스

→ B-Tree 검색 시간을 줄여주기 위해 도입

- 방식

자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아감 (더 많은 쿼리 동시 처리 가능)

인덱스 키 값 - 데이터 페이지 주소 쌍으로 관리

- 사용이 유리할 경우,
    - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)
    - 동등 조건 검색 (동등 비교 IN 연산자)가 많은 경우
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

- 사용이 불리할 경우,
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우(JOIN / LIKE)
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭 넓게 읽는 경우
- 버퍼풀 내에서 접근하는 것을 빠르게 하는것이라 디스크 읽어오는건 빨리할 수 없음

** v8.0부터 MySQL 모든 기능을 InnoDB 스토리지 엔진만으로 구현 가능

MyISAM 스토리지 엔진만이 갖는 장점 없음 (도태)
MEMORY 스토리지 엔진 : 동시처리 기능은 이노디비와 비교 불가. 하나의 스레드에서는 빠를 수도 있음 (도태)

### MyISAM 스토리지엔진 아키텍처 구조


![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/edc5140d-f8f0-48bb-98e1-35e22053a0fc/Untitled.png)

- 키 캐시 → 인덱싱 속도를 빠르게
    - = InnoDB의 버퍼 풀
    - 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할
    - 키 캐시를 이용한 쿼리의 비율을 99% 이상으로 유지하라고 권장
- 운영체제 캐시 → 디스크로부터 I/O 를 해결해 줄 만한 캐시 기능 제공
- 데이터 파일
    - InnoDB - 프라이머리 키에 의해 클러스터링 되어 저장
    - MyISAM 테이블 : 데이터 파일이 heap 공간처럼 활용 (프라이머리 키 값과 무관하게 INSERT 됨)
    - 프라이머리 키와 세컨더리 인덱스 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가짐)

### MySQL 로그 파일


: MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있음

- 에러 로그 파일

  : MySQL 실행되는 도중 발생하는 에러나 경고 메시지가 출력되는 로그 파일

- 제너럴 쿼리 로그 파일

  : MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 검토할때 사용

시간 단위로 실행됐던 쿼리 내용 모두 기록