> 9장. 전문 검색 기술의 응용 범위
>

### 하테나 다이어리 전문검색

하테나 다이어리 검색엔진 : 하테나 다이어리의 전문을 검색 대상으로하여 하테나 **키워드**로 이를 검색 가능하게 하는 시스템 (키워드(Dictonary) 에 포함되어 있는 단어만을 검색)

‘Perl을 포함하는 블로그 ’ → 블로그 본문에 ‘Perl’ 이라는 키워드가 포함되어 있는 블로그의 목록

1. RDB로 처리
    1. 새로운 글을 작성했을 때 해당 글에 포함되어 있는 키워드 전부 추출
    2. ‘a 단어 - a 블로그’ 연관성을 모두 매핑하여 RDB에 저장
    3. 레코드 수가 너무 많아져 확장성에 어려움을 가짐
2. 검색 기술 응용
    1. 사용자가 검색하면 이를 검색 서비스에서 검색하여 결과를 얻음
    2. 특징 : 출력이 일자순으로만 나오면 된다고 결론지어짐(검색 서비스 : C++로 구현, Perl과의 인터페이스 : Thrift) → 단순한 결과만으로 고속화
3. 전문 검색(세세한 요구를 만족시키기 위해)
    1. 하테나 서비스 중 ‘마이 북마크 검색’ : 자신이 북마크한 사이트만을 대상으로한 전문 검색
    2. 시스템의 규모, 이용목적에서 위의 기술들과 다름
        1. 스닛핏(snippet) : 검색결과에 본문의 일부를 표시하는 기능

           : 검색어가 문서 내의 어느 위치에 있는 단어와 매칭되는지를 기록할 필요가 있음

    3. 구현 방법:
        1. 각 사용자별로 검색 인덱스를 준비해두고 이를 갱신
        2. 검색시에는 각 사용자의 인덱스에서만 검색

### 검색 시스템

- 검색 시스템 프로세스
    1. 크롤링
    2. 저장
    3. **인덱싱**
    4. **검색**
    5. 스코어링
    6. 결과 표시

- 전문 검색의 종류
    - grep형
        - 검색 대상 문서를 처음부터 전부 읽음 (O(mn))
        - 갱신되더라도 바로 검색 가능
        - 검색 누락 없음
        - 병렬화나 쿼리 확장에 용이
        - 대규모 환경에서는 무리가 있음
    - sufix형
        - trie, suffix array(접미사 배열), suffix tree 를 자료구조로 차용
        - 문서를 검색 가능한 형태로 가지고 있으며 전부 메모리에 올릴 수 있는 형태가 됨
        - 정보량이 크고 구현이 어려움

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/1b3a47fb-366c-4973-802a-6034eb658b06/Untitled.png)

    - 역 인덱스형
        - 단어와 문서를 연관짓는 것
        - 역 인덱스를 문서와는 별개로 만들어야 함 (검색 전 인덱스를 전처리로 만들어야 함)
        - 문서 변경시 검색결과 바로 갱신 불가

### 검색엔진의 내부 구조

- 역 인덱스의 구조

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/6ac80ce4-4969-4a8f-9177-9c39f1cf7b78/Untitled.png)

- 인덱스 - 역인덱스

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/e54bf458-ec26-4043-9241-5ecfb6c9765d/Untitled.png)

- 인덱싱 : 레코드에서 대표하는 값을 뽑기 때문에 문서에서 키워드를 뽑는 색인레코드에서 대표하는 값을 뽑기 때문에 문서에서 키워드를 뽑는 색인
- 역인덱싱 : 키워드를 통해 문서를 찾아내는 방식
    - 역 인덱스 = Dictonary + Postings
    - 단어 ‘term’ 과 term 의 집합 ‘Dictonary’, 이에 연결되어 있는 ‘Postings’
    - 단어로 검색하면 몇 번 포함되어 있는지, 어떤 문서에 어떤 단어가 포함되어 있는지 알 수 있음

- Dictonary 만드는 법
    - term을 어떻게 선택하느냐에 차이
        - 미리 정해놓은 사전 사용,형태소 분석하여 단어 분리 / n-gram기법으로 단위를 나눔
        1. 단어를 term으로 사용
            1. 영어는 공백으로 가능
            2. 일본어는 공백이 없고 단어의 분기점이 어디 있는지 모름

           → 검색 누락 발생 가능

        2. n-gram을 term으로 사용
            1. 텍스트를 n자씩 잘라서 term으로 만듬
            2. ‘하테나의 마스코트인 시나몬은 도쿄에 없다’

               : 2-gram으로 하면 ‘하테’,’테나’,’나의’,…

           → 잘못된 검색을 수행하는 문제


        ⇒ 필터링 시간의 소요로 단어 기반 사용
        
    - 재현률(Recall)과 적합률(Precision)
        - 재현률 : 문서 전체에는 단어를 포함하는 문서가 얼마나 있고, 검색엔진이 그 중에서 얼마만큼 검색 결과를 반환했는지
        - 적합률 : 반환한 결과에 얼마나 정확한 결과가 들어있는지
        
        ⇒ 이 개념으로 성능을 정량화하여 검색의 타당성 평가 가능
        
    
    |  | 형태소 분석 | n-gram |
    | --- | --- | --- |
    | 특징 | 검색되었으면 하는게 검색되지않는 경우 발생 | 검색누락은 없지만 의도하지 않는 결과 반환 |
    | 주안점 | 적합률이 우선시 | 재현률이 우선시 |

- Postings 만드는 법
    - ID만 보유 / 출현위치 저장(스니핏에 도움)
    - 스코어링에 도움
        - ‘하네타’ and ‘교토’ 로 검색했을때 단어사이의 근접도로 스코어링 가능

  | 출현위치 저장 | 문서 ID만 저장 |
      | --- | --- |
  | Full Inverted Index | Inverted File Index |
  | 스니핏, 스코어링, 필터링 용이 | 크기가 작고 구현이 용이 |

- 스코어링
    - 단어사이의 근접도
    - 문서 내의 중요도
    - 등 여러가지의 방식으로 검색 엔진에서 의미있는 정보를 상단으로 올리도록 설계