> 분산을 고려한 My SQL 운용
>

1. OS 캐시 활용

→ 전체 데이터 크기에 주의해 데이터량 < 물리 메모리

⇒ MySQL 에서는 레코드가 가능한 작아지도록 설계하기 (→ 정규화도 고려)

1. 인덱스
- 기본 인덱스 알고리즘 : 트리(탐색 트리)

    MySQL - B+트리 데이터 구조 사용

    - 이분트리와 B트리 구조의 차이점
    - [https://velog.io/@jewelrykim/Binary-Search-Tree에서-BTree까지Database-Index-추가](https://velog.io/@jewelrykim/Binary-Search-Tree%EC%97%90%EC%84%9C-BTree%EA%B9%8C%EC%A7%80Database-Index-%EC%B6%94%EA%B0%80)
- 인덱스의 효과
    - 없을 경우 O(n) 번 탐색
    - 있을 경우 O(log n) 번 탐색 → 계산량, 디스크 Seek 횟수 개선
    - but, 데이터의 갯수가 작다면 트리를 순회하는 오버헤드가 더 커서 그냥 찾는게 나을때도 있음. MySQL은 총 건수를 보고 판단

1. 확장을 한다는 전제로 시스템 설계
- ‘분산’을 어떻게 실현해갈 것인가
    - MySQL 의 replication (Master - Slave)

        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/9f638b7a-b4a4-490a-9934-28a04831f771/Untitled.png)

        마스터에 쓴 내용을 슬레이브가 폴링하여 동일한 내용으로 자신을 갱신

        → 갱신은 마스터로 던짐, 참조쿼리만 슬레이브

    - 특징
        - 참조계열은 확장, 갱신계열은 확장X
        - 마스터는 확장하지 않으므로 갱신 계열 쿼리가 늘어나면 의미 없음
        - 서버 대수를 늘려 필요한 메모리를 맞춤
    - 다중화에 필요한 서버 대수 계산법
        - 마스터 1대 + 슬레이브 3대가 적합 (총 4대가 1세트)
            - 슬레이브가 2대일 경우, 슬레이브 1대 장애시, 다시 올리기 위해 살아남은 다른 슬레이브를 중지시켜 데이터를 복사해야함
    - 갱신/쓰기 계열 확장 - 테이블 분할, key/value 스토어
        - 테이블을 분할하여 크기를 작게하고 쓰기작업 분산
        - RDBMS가 아닌 key-value 사용 고려

1. MySQL 의 스케일 아웃과 파티셔닝
- 스케일 아웃
    - 데이터가 메모리에 올라가는 크기? → 메모리에 올림
    - NO → 메모리 증설
    - 메모리 증설 불가능시 파티셔닝
- 파티셔닝
    - 테이블을 서로 다른 서버에 놓아서 분산하는 방법

        → 다른 파티션의 테이블은 조인 불가

        ⇒ 기본적으로 조인 쿼리는 대상이 되는 테이블을 앞으로도 서버 분할하지 않을 것이라고 보장할 수 있을 때만 사용

        → 때때로 조인을 쉽게 걸지않고 `where... in` 절로 결합하는 쿼리를 임의로 설정하여 의존성을 낮출 필요도 있음

    - 파티셔닝의 상반관계
        - 운용 복잡
            - 장애 발생시 고장 시점 파악 어려워짐 → 복구에 시간 걸림
        - 고장률 높아짐
            - 관리 포인트 많아짐
        - 부하가 내려감
        - 캐시 효과가 높아짐