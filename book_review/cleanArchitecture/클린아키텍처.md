## 1. 클린 아키텍처

- 여러가지 아이디어들

```json
[육각형 아키텍처 (Hexagonal Architecture)] - 포트와 어댑터 (앨리스터 코오번)
[DCI (Data, Context and Interaction)] -  제임스 코플리언 & 트리그베 린스쿠주
[BCE (Boundary-Control-Entity)] - 이바 야콥슨
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/9dee0733-cd88-4f17-86b1-09c5f2a75788/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/d335e9f8-0708-49b9-8e1b-f4c8c64933c8/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/7a7d0e40-81a1-41bc-975d-f9d7e735e75d/Untitled.png)

> 가장 큰 목표 : “**관심사의 분리 (separation of concerns)”**
>

→ 소프트웨어를 계층으로 분리

⇒ 최소한 업무 규칙을 위한 계층 | 사용자와 시스템 인터페이스 계층으로 나뉨

- 이러한 아키텍처의 특징
    - 프레임워크 독립성
      프레임워크의 존재 여부에 의존하지 않음 → 프레임워크가 지닌 제약사항 안으로 시스템을 욱여 넣도록 강제하지 않음
    - 테스트 용이성

      업무 규칙은 UI, 데이터베이스 등의 외부 요소 없이도 테스트할 수 있음

    - UI 독립성

      시스템의 나머지 부분을 변경하지 않고도 UI 변경 가능

    - 데이터베이스 독립성

      DB 쉽게 교체 가능. 업무 규칙은 데이터베이스에 결합되지 않음

    - 모든 외부 에이전시에 대한 독립성

      실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알 수 없음

      Q. 위의 아키텍처들, 그리고 클린 아키텍처를 봤을 때 드는 생각은 **클래스가 정말 많아진다**는 것이다.
      앞서 설명했듯, 독립성의 측면에서는 이점을 가져갈 수는 있지만 실무에서는 급하게 DB를 바꾼다거나 테스트를 하지 않는 경우들도 많다.

      과연 앞의 아키텍처들이 실무에서도 효율적이라고 생각이드는지? 든다면 어떤 측면에서 좋을지 궁금합니다.

      (타고타고 들어가게 되는 이런 코드가..좋은 걸까..? 라는 의문 feat.올림푸스…)

        - Answer

          도연님 : 아키텍처만 보고서도 도메인을 알수 있어야하는데, 과연 이전 장에서 언급했듯 ‘소리치는 아키텍처’라는 주제와 일치하는가?
          UI가 변경되는 일은 많이 없다고 생각함. 외부 플러그인으로의 확장성이라면 나쁘지 않다고 생각
          정현님 : 필요에 의해 많아지는 클래스는 용인할 수 있음. ‘필요’라는게 모호하긴 함. 올림푸스 프로젝트에서 변환하는 과정을 추가하게 되면서 DB 종속 또는 공통적인 코드에서의 문제점을 해결하게 됨. 때에 따라 다르다

          보형님 : 바이퍼라는걸 사용하면서 인터렉터를 많이 사용 → 네트워크 / 뷰 문제 인지 오류 상황에서 특정 레이어의 문제로 파악하기 쉬웠음

          미소님 : 정현님 말에 동의. 융통성있게. 고수준에서는 클래스 관계가 점점 많아지게 되고, 숨어있는 소스들이 많아지면 관리에 혼란을 야기할 수 있음


        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/5e3889fb-ba28-402a-b96b-7c5f4bf02273/Untitled.png)
        
        두둥! 클린 아키텍처!


- 클린 아키텍처의 규칙 - **의존성 규칙**

  > **소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.**
  안으로 들어갈수록 고수준의 소프트웨어
  >

  바깥쪽 : 메커니즘
  안쪽 : 정책

    - 내부 원에 속한 요소 : 외부의 원에 속한 어떤 것도 알지 못함

      ++ 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안됨
      → dto 재사용 X


### 내부 구성

- 엔티티

  : 전사적인 핵심 업무 규칙을 캡슐화

  외부의 무언가가 변경되더라도 엔티티가 변경될 가능성은 지극히 낮음 (pure한 객체)


- 유스케이스

  : 애플리케이션에 특화된 업무 규칙을 포함

  유스케이스 계층 - 시스템의 모든 유스케이스를 캡슐화하고 구현

  엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끔

  but, 이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안됨 + 외부 요소에서 발생한 변경이 이 계층에 영향을 줘서도 안됨 (= 관심사의 분리)


- 인터페이스 어댑터

  : 일련의 어댑터들로 구성

  어댑터 : 데이터를 유스케이스와 엔티티에게 가정 편리한 형식에서 외부 에이전시에게 가장 편리한 형식으로 변환

  (프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층)

  흐름 : 컨트롤러 - 유스케이스 - 프레젠터 & 뷰


- 프레임워크와 드라이버
  : 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성
  모든 세부 사항이 위치하는 곳 (외부에 위치시켜 피해를 최소화)

### 원의 개수?

→ 원은 꼭 4개만 있어야하는 법은 없음

단, 중요한 것은 소스 코드 의존성은 항상 안쪽을 향함!

안쪽으로 이동할수록 추상화와 정책의 수준은 높아지고,

바깥쪽으로 이동할수록 저수준의 구체적인 세부사항으로 구성

### how to 경계 횡단?

제어의 흐름 :
컨트롤러 → **유스케이스 → 프레젠터**

소스 코드 의존성 :
안쪽으로 흐름

- 제어의 흐름 ↔ 소스 코드 의존성이 반대여야하는 경우 의존성 역전 원칙 (인터페이스, 상속 관계) 이용

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/e0e2c7f2-6a27-479c-9303-cdadcc0e8ca1/Untitled.png)

- 횡단 데이터의 모습
    - DO
        - 전송 객체 (dto)
        - 간단한 인자 사용
        - 해시맵 / 객체 사용

      → 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가지는 것이 좋음

    - DON’T
        - 엔티티 객체 자체
        - 데이터베이스의 행 자체

      → 데이터 구조가 어떤 의존성을 가지면 안됨

      ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/d753fef1-fd26-4bee-9543-5fae8539863e/Untitled.png)


    <aside>
    💡 의존성 방향에 주목하라.
    
    모든 의존성은 **경계선을 안쪽으로 가로지르며**, 따라서 의존성 규칙을 수행한다.
    
    </aside>
    
    ㅁ…뭔..소리고… 설명해주실 분 구해요


## 2. 프레젠터와 험블 객체

- 험블 객체 패턴

  : 디자인 패턴의 일종, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법

→ 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 이동 (짬 때리고 중요한 것만 테스트 할 수 있도록)

- 테스트와 아키텍처

테스트하기 쉬운 부분과 어려운 부분을 나누다보면 **아키텍처의 경계를 정의**할 수 있음

- 프레젠터와 뷰

|  | 특징 | 역할 |
| --- | --- | --- |
| 뷰 | 험블 객체 | 데이터를 GUI로 이동, 데이터를 직접 처리하지는 않음 |
| 프레젠터 | 테스트하기 쉬운 객체 | 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것 (실제 데이터 가공) |
- 데이터베이스 게이트웨이

  : 유스케이스 인터렉터 - 데이터베이스 사이에 존재

다형적 인터페이스 : CRUD 포함

유스케이스 계층 ↔ 데이터베이스 게이트웨이 ↔ SQL(DB)

구현체 : 험블 객체

데이터베이스 게이트웨이 : 스텁이나 테스트 더블로 교체 가능

- 데이터 매퍼

  : ORM (객체 관계 매퍼) - 관계형 데이터베이스 테이블로부터 가져온 데이터를 데이터 구조에 맞게 담아줌

데이터베이스 계층 (자세히는 게이트웨이 인터페이스 ↔ 데이터베이스 에서 경계 생성)

- 서비스 리스너

  : 외부로부터 데이터를 수신하는 서비스의 경우, 서비스 인터페이스로부터 데이터 수신 및 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷 변경

## 3. 부분적 경계

### Problem

클린 아키텍처의 문제점 : 경계를 만드는 비용이 너무 큼!
YAGNI(You Aren’t Going to Need it) 원칙 위배 - 오버 엔지니어링

⇒ 부분적 경계로 절충 가능

- 부분적 경계 1 - 독립적 컴포넌트 만들기

  : 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아둠
  → 단일 컴포넌트로 컴파일해서 배포

    - 단 :  결국 완벽한 경계 만큼의 코드량과 사전 설계 필요
    - 장 :
        - 다수의 컴포넌트 관리 필요 없음
        - 버전 번호 없음
        - 배포 관리 부담 없음

`FitNesse 사례`

: 별도로 분리한 웹 컴포넌트가 재사용될 가능성이 없고, 컴포넌트 사이의 구분도 악화됨

- 부분적 경계 2 - 일차원 경계

앞서 설명한 아키텍처 경계는 양방향으로 격리된 상태를 유지해야함
→ 초기 설정, 지속적 유지시 비용 많이 듬

⇒ 전략 패턴을 사용하여 확장성있는 구조를 설계
(점선을 통한 호출도 가능하므로 개발자의 잘못으로 다시 경계를 허물 수도 있음)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/e8fc3141-6a29-4b18-8db2-2a593db5edee/Untitled.png)

전략패턴 : 객체가 할 수 있는 행위들 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴

- 부분적 경계 3 - 퍼사드

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4eb17d17-9fd9-456b-9cd6-805a7036e822/ca248648-c503-4669-828c-9375082c9f76/Untitled.png)


의존성의 역전까지도 희생 …(?)

-Fadade 클래스에서 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달

-클라이언트는 서비스 클래스에 직접 접근할 수 없음 (여기서 경계가 생기는 건지)

단 : Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 됨

⇒ 세 가지 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다름

경계가 언제, 어디에, 완벽/부분 으로 구현할지 결정하는 일이 중요