<aside>
💡 객체 지향 프로그래밍

</aside>

Q. OO (Object-Oriented)란 무엇인가?

- 데이터와 함수의 조합
- 실제 세계를 모델링하는 새로운 방법
- 최소한 세 가지 요소를 만족하는 것
    - 캡슐화
    - 상속
    - 다형성


**Q. 이전에는 객체지향의 4원칙으로 캡슐화, 상속, 다형성 그리고 추상화 에 대해 배웠는데, 이번 책에서는 왜 추상화의 개념에 대해서는 언급되지 않았을까?**

- Answer

  도연님 : OO의 아이덴디티는 위의 세가지라고 생각. 추상화는 상속의 연장선이라고 생각한다.

  보형님 : 다형성을 강조하기 위해 원칙에 대해 간략히 한 것. 빠르게 대처, 유연성을 강조하기 위함. 추상화라는 개념이 어떤 레벨까지 추상화하냐가 개발자마다의 모호한 부분

  정현님 : 다형성을 강조하는게 큼. 다형성은 캡슐화와 상속없이 말할 수 없는 부분. 추상화는 기본적인 개념이기 때문


**Q. 앞서 얘기한 4가지 원칙 중 본인이 가장 중요하다고 생각하거나 염두에 두고 개발하고 있는 개념은?**

- Answer

  정현님 : 상속. 캡슐화는 기본적인 개념, 다형성은 직접적인 고려를 하면서 개발한적은 없음. 상속을 잘 구현한다면 개발자의 행동을 잘 제어할 수 있다고 생각

  보형님 : 캡슐화를 먼저 생각. 개발을 한 후에는 private 처리를 할 수 있는게 있는지 파악

  도연님 : 캡슐화, 상속. 다형성을 구현하는것은 쉽지 않음. 다운캐스팅 등의 개념을 적용하기 위해서는 메모리에 대한 개념이나 기본적인 컴퓨터 지식을 알고 있어야하기 때문

  준희님 : 4가지 원칙보다도 전반적으로 유지보수가 잘 되었으면 좋겠음


### 1. 캡슐화

- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출되도록 하는 것
  → public과 private 으로 구분
- 데이터의 응집도를 높임

📢 **반박 :**  OO가 아닌 언어도 지원가능 (C언어)

→ 오히려 c++에서 완벽한 캡슐화가 훼손됨

→ 실제로 많은 OO언어가 캡슐화를 거의 강제하지 않음 (Python, JS, Ruby..)

→ 프로그래머가 캡슐화된 데이터를 우회해서 사용하지 않을거라는 믿음이 있어야 함

- code

  c언어

    ```c
    **point.h // point.c의 내부 코드에 대해 알 방법이 없음
    // 헤더파일 : 데이터 구조와 함수를 선언**
    struct Point;
    struct Point* makePoint(double x, double y);
    double distance (struct Point *p1, struct Point *p2);
    
    **point.c
    // 구현파일 : 세부 내용 구현**
    #include "point.h" // 
    #include <stdlib.h>
    #include <math.h>
    
    struct Point {
    	double x,y;	
    }
    
    struct Point8 makepoint (double x, double y) {
    	struct Point* p = malloc(sizeof(struct Point);
    	p -> x = x;
    	p -> y = y;
    	return p;
    }
    
    double distance(struct Point* p1, struct Point* p2) {
    	double dx = p1 -> x - p2->x;
    	double dy = p1 -> y - p2->y;
    	return sqrt(dx*dx+dy*dy);
    }
    ```

  c++

    ```cpp
    **point.h // 헤더파일**
    class Point {
    ****public :
    	Point(double x, double y);
    	double distance(const Point& p) const;
    
    private : // 클래스의 멤버변수를 헤더파일에 선언 필요 **(내부의 속성을 알아야하게됨)**
    	double x;
    	double y;
    }
    **point.cc**
    #include "point.h" // 
    #include <math.h>
    
    Point::Point (double x, double y) 
    : x(x), y(y)
    {}
    
    double Point::distance(const Point& p) const {
    	double dx = x-p.x;
    	double dy = y-p.y;
    	return sqrt(dx*dx + dy*dy);
    }
    ```


### 2. 상속

- 기존의 클래스를 재활용하여 새로운 클래스를 작성
- 딱 한 번만 정의해두고 간편하게 **재사용**할 수 있어 **반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근**하여 사용
- 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의 (근본이 변화하지는 X)

📢 **반박 :**  상속 이전에도 그걸 따라하려는 노력이 있었음 (편리하진 않음)

⇒ OO에서의 상속 : 완전히 새로운 개념은 아니지만 데이터 구조를 편리한 방식으로 제공할 수 있도록 도움

### ⭐️ 3. 다형성 ⭐️

- 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
    - 메서드 오버로딩 이나 메서드 오버라이딩
- 결합도를 낮춰줌 (독립적, 플러그인 형태)

** 플러그인 아키텍처

: 시스템 독립적, 어디에나 적용가능(유연)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0c71ec4-25d2-4867-a6fc-be56472ec70e/Untitled.png)

📢 **반박 :** 기존에 함수를 가리키는 포인터를 응용한 것이 곧 다형성

- OO : 다형성을 좀 더 안전하고 편리하게 사용할 수 있도록 해줌
    - 기존 포인터의 한계 : 포인터를 초기화, 포인터를 통해 모든 함수를 호출해야하는 관례를 지키지 않으면 버그 발생

- 다형성을 안전하게 사용하는 방법 - 의존성 역전
    - 제어의 흐름(=의존성)은 시스템의 행위에 따라 결정이 되며, 소스 코드 의존성은 제어흐름에 따라 결정
    - 소스 코드 사이에 의존성을 추가함으로써 방향을 역전시킬 수 있음

  ⇒ OO언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 소스 코드 의존성 전부에 대해 방향을 결정할 수 있음

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89f2b9e2-f7fd-48fa-8b51-50a5690f2aa3/Untitled.png)

- 이점
    - 의존성 역전을 통해 OO는 다형성을 안전하게 사용하게 됨
    - 시스템의 의존성을 원하는 방향으로 바꾸면서 호출하는 주체를 바꾸고, 결과적으로 독립적으로 개발 및 배포가 가능함
        - 배포 독립성 (independent deployability)

          : 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포

        - 개발 독립성 (independent developability)

          : 서로 다른 팀에서 각 모듈을 독립적으로 개발 가능


![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bfda2133-5e36-476b-8cef-639e36747ed2/Untitled.png)

### 저자가 생각하는 OO란?

- 다형성을 이용하여 전체 시스템의 모든 소스 코드 **의존성에 대한 절대적인 제어 권한**을 획득 할 수 있는 능력
- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 **모듈에 대해 독립성을 보장**
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 **독립적으로 개발 및 배포 가능**

**Q. OO란 무엇이라고 생각하는지? 저자가 한 OO에 대한 정의에 대해 어떻게 생각하는지?**

- Answer

  도연님 : 후반의 클린 아키텍처를 설명하기 위해서는 ‘다형성’의 개념이 중요하기 때문.  앞서 이야기한 상속과 캡슐화의 반박 근거가 정당하다고 생각하지 않고, 다형성의 개념을 중요하게 이야기하기 위함인 것 같음

  정현님 : 앞서 얘기한 캡슐화와 상속에 대한 얘기는 중요하지 않아보였음. “OO란 플러그인이다” 를 강조하고 싶어보였음.

  보형님 : 재사용,  빠른 개발에 대한 내용에서는 프로그램 첫 개발보다는 유지보수에 대한 이야기인 것 같음. 유지보수에는 다형성이 꼭 필요한 부분이므로 얘기했다고 생각함. 클린 아키텍처는 미래에 대한 ‘확장성’에 대한 개념인듯함

  준희님 : 동의. (보감)


**Q. 상속(Inheritence) vs 합성 (composition)**

| **상속(Inheritance)** | **합성(Composition)** |
| --- | --- |
| 부모 클래스와 자식 클래스 사이의 의존성은 **컴파일 타임에 해결** | 두 객체 사이의 의존성은 **런타임에 해결** |
| is-a 관계 | has-a 관계 |
| 부모클래스의 구현에 의존 결합도가 높음. | 구현에 의존하지 않음.내부에 포함되는 객체의 구현이 아닌 인터페이스에 의존. |
| 클래스 사이의 정적인 관계 | 객체 사이의 동적인 관계 |
| 부모 클래스 안에 구현된 코드 자체를 물려 받아 재사용 | 포함되는 객체의 퍼블릭 인터페이스를 재사용 |

```java
// is-a
class Mobile {
	// ...
}

class Apple extends Mobile {
	// ...
}
```

```java
// has-a
// 수직관계가 아닌 수평 관계

class Car {
    Engine engine; // 필드로 Engine 클래스 변수를 갖는다(has)

    Car(Engine engine) {
        this.engine = engine; // 생성자 초기화 할때 클래스 필드의 값을 정하게 됨
    }

    void drive() {
        System.out.printf("%s엔진으로 드라이브~\n", engine.EngineType);
    }

    void breaks() {
        System.out.printf("%s엔진으로 브레이크~\n", engine.EngineType);
    }
}

class Engine {
    String EngineType; // 디젤, 가솔린, 전기

    Engine(String type) {
        EngineType = type;
    }
}
```

ref) https://mangkyu.tistory.com/199

- Answer

  도연님 : 상속을 위해서는 추상화가 필요. 부모를 봤을때는 자식이 맞지만, 같은 형제 레벨에서는 완전히 다른 성격일 때가 있음. 상속에 개념에 알맞는 분리인가에 대한 고민을 계속해야함
  반면 합성에서는 그러한 고민이 없어서 좋음

  준희님 : 잘 짜여져 있는 큰 개념일때는 상속, 자주 바뀌는 것에 대해서는 합성으로 해결하는 것이 좋음. 두 개 중에 더 좋은 개념은 없다고 생각

  정현님 : 상속과 합성을 따지는 상황이 모델을 짜는데 있는 상황. 맡고 있는 색인의 도메인에서는 주로 상속을 사용하는게 좋았음. 상속이 행동 제어를 하는데 편한 아키텍처라고 생각

  보형님 : 색인 같은 응답이 변하지 않는 경우에서는 상속으로 구현. 합성과 상속을 결합하여 유연하게 사용하는 것이 좋아보임