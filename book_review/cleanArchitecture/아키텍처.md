## Ch 15. 아키텍처란?

소프트웨어 시스템의 아키텍처?

→ 시스템을 구축했던 사람들이 만들어낸 시스템의 형태

### 정해지는 방법

- 시스템을 컴포넌트로 분할하는 방법
- 분할된 컴포넌트를 배치하는 방법
- 컴포넌트가 서로 의사소통하는 방식

### 목적

- **시스템의 생명주기를 지원하는 것**
- 쉽게 개발, **배포, 운영, 유지보수**될 수 있도록

→ 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화

**⇒ 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략 추구**

**Q. 개인적으로 코드레벨에서는 오히려 확장성만 생각하는 오버 엔지니어링식의 개발이라고 생각했었는데,**

**소프트웨어 아키텍처 레벨에서의 확장성을 추구하는 방식에 대해서는 어떻게 생각하는지 궁금합니다.**

- Answer

  도연님 : 이미 기존의 만들어진 구조는 추상화가 되어있고, 외부의 영향을 받지 않는 클린 아키텍처로 되어있다. 그 이후의 확장 방법에 대해 이야기 하고 있음 (무결점의 소프트웨어 이후 확장을 했다)

  정현님 : 코드레벨에서의 확장 →  기획의 확장이라고 생각함. 저자의 이야기는 플러그인 아키텍처를 위주로 이야기 하려한 것 같음

  미소님 : 유지보수의 비용에 대해서 고려를 많이 한 것 같음. 컴포넌트로 독립화하여 만드는것을 이야기하고 있는 것 같음

  보형님 : 소프트웨어 아키텍처 레벨은 코드레벨보다 큰 의미라고 생각. 변경에서의 사이드이펙트를 안나게 하는 유연한 구조를 만드는 것이라고 생각


### 각 단계에서의 아키텍처

1. 개발

시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침 해야한다.

(팀의 규모, 구조에 맞게 아키텍처는 구축되어져 감)

1. 배포

시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야한다.

(초기 단계에 배포 전략을 고려하지 않아 배포가 어려워지는 점. ex.msa )

1. 운영

비용 공식 관점에서 운영보다는 개발, 배포, 유지보수 쪽으로 더 중심을 기울이는게 좋다.

(운영 문제는 하드웨어를 추가하면 해결 할 수 있기 때문)

but, 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. (개발, 유지보수에 도움)

Q. 이 부분 잘 이해가 안가요. 운영과 유스케이스의 필수 행위는 무슨 연관관계인가

1. 유지보수

가장 비용이 많이 듬

탐사(spelunking)과 이로 인한 위험부담

탐사? : 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용 (위험부담이 동반됨)

→ 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다. (장애 발생 위험 줄임)

### 아키텍처 구성 방법

소프트웨어를 soft하게 유지하기 위한 유연성은 **시스템의 형태, 컴포넌트의 배치방식, 컴포넌트가 상호 연결되는 방식에** 크게 의존

1. 선택사항 열어두기
- 정책 (policy) : 모든 업무 규칙과 업무 절차를 구체화
- 세부사항 (detail) : 정책이 가진 행위에 영향을 미치지 않는 입출력 장치, db, 웹 시스템, 서버, 통신 프로토콜 등

**시스템에서 정책을 가장 핵심적인 요소로 식별, 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축**

→ 세부사항을 무관하게 뒀을 때 비로소 시스템에 맞는 세부사항들을 시도 및 선택할 수 있음

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다.
>

1. 장치 독립성

개방 폐쇄 원칙과 비슷하게 동일한 프로그램에서 변경없이 장치를 연결 할 수 있도록 (장치 또한 세부사항)

## Ch. 16 독립성

### 아키텍처가 지원해야하는 4가지

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

1. 개발 독립성

컴포넌트로 완전히 분리되면 서로의 개발에 개입할 가능성이 거의 없음

1. 배포 독립성

계층/ 유스케이스의 결합이 분리 되었다면, 새로운 jar 이나 서비스 몇 개를 추가하는 일은 어렵지 않을 것

(배포 독립적으로 추가 가능)

1. 중복
- 진짜 중복

  : 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야함

- 거짓된 or 우발적인 중복

중복으로 보이는 두 코드 영역이 서로 다른 속도와 이유로 각자의 경로로 발전 (결국 달라짐)

> 중복이 진짜 중복인지 확인하라
>

진짜 중복인 줄 알고 섣불리 코드를 통합했다가는 다시 분리하는데 큰 수고를 감수해야 함

---

1. 유스케이스

   : 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.

아키텍처가 시스템의 행위에 직접적인 영향은 X

but, 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있도록 함

(유스케이스는 시스템 구조 자체에서 한 눈에 드러남)

1. 운영

운영을 어떤 방식으로 구현을 할지는 열어두어야 하는 선택 사항

(다중 프로세스, 다중 스레드…)

→ 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것

1. 개발

콘웨이의 법칙?
: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것

각 팀마다의 독립적인 아키텍처를 컴포넌트 단위로 만들어서 시스템을 분할 할 수 있어야한다.

1. 배포

즉각적인 배포를 목표로 함

- 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않음
- 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않음
- 시스템이 빌드된 후 즉각 배포할 수 있도록 지원

→ 시스템을 컴포넌트 단위로 격리시키고, 마스터 컴포넌트가 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리

### 아키텍처 구성 방법

1. 선택사항 열어두기

현실의 시스템은 계속 변하고 미리 알 수 없는 정보들로 위의 이상적인 원칙을 맞출 수 없음
→ 원칙의 균형을 최대한 맞추고 선택사항을 열어둠으로써, 향후 시스템에 변경이 필요할 때 변경해라

1. 계층 결합 분리

단일 책임 원칙 / 공통 폐쇄 원칙을 적용
→ 의도와 맥락에 따라 다른 이유로 변경되는 것들은 분리. 동일한 이유로 변경되는 것들은 묶음

⇒ UI / 애플리케이션 특화 업무 규칙 (어플리케이션 서비스) / 애플리케이션 독립 업무 규칙 (도메인 서비스) / db
의 수평적인 계층으로 분리 가능

1. 유스케이스 결합 분리

유스케이스 : 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각

→ 수직으로 길게 분리하여 유스케이스들이 각 계층에서 서로 겹치지 않게 함

⇒ 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있음 ( = 유스케이스의 서로 다른 관점 분리)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7c447ffa-a8e9-4165-a539-12d0bd6819f6/Untitled.png)

1. 결합 분리 모드

유스케이스가 분리되었다면 각 유스케이스를 분리하여 여러 서버로 복제하여 실행 할 수도 있음
→ 이러한 컴포넌트들을 서비스 지향 아키텍처(SOA) 라고 부름

[SOA란 무엇인가요? - 서비스 지향 아키텍처 설명 - AWS](https://aws.amazon.com/ko/what-is/service-oriented-architecture/)

SOA가 답은 아니지만, 컴포넌트를 서비스 수준까지 분리해야하는 상황이 있을 수 있고 **그를 위해 좋은 아키텍처는 선택권을 열어둔다.**

- 유스케이스의 결합을 분리하는 방법
    - 소스 수준 분리 모드
        - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 **재컴파일하지 않도록 만들 수** 있음
        - 모든 컴포넌트가 같은 주소 공간에서 실행, 함수로 호출, 컴퓨터 메모리에 하나의 실행파일만이 로드 (모노리틱 구조)
    - 배포 수준 분리 모드
        - jar 파일, DLL 과 같이 배포 가능한 단위
        - 한 모듈의 소스 코드가 변경되더라도 재빌드나 재배포 안함
        - 많은 컴포넌트가 같은 주소 공간에 상주, 함수 호출, 프로세스 간 통신, 소켓 통신 등
          ( 배포 파일은 여러개)
    - 서비스 수준 분리 모드
        - 네트워크 패킷을 통해서만 통신
        - msa

**Q. 개발 초기 단계에서는 어떤 모드를 골라야 하는가?**

- Answer

  Martin : 서비스 수준의 분리를 기본 정책으로 하고, 서비스가 되기 직전에 멈추는 방식을 선호. 컴포넌트들은 같은 주소 공간에 두어 모드의 선택권을 열어 둠

  정현님 : 초창기에는 서비스의 사이즈가 작을거라고 생각. 모노리틱 → 볼륨이 커져서 빌드 시간이 오래걸리거나를 시작했을 때 분리 → 서비스 수준으로 분리한다
  뭉쳐져 있더라도 쪼갤 수 있도록 설계를 하는 것이 중요

  미소님 : 수평 / 수직으로 자르다보면 각각의 개발자가 필요한 것 아닌가.

  도연님 : 정현님 방식에도 동의. 스타트업에서는 처음 설계부터 서비스 수준의 분리를 하기도 함. ddd 설계를 넣기도 했는데, 너무 자잘하게 분리되어있어 ddd의 방식으로 묶을 수 있도록 함
  msa가 트렌드는 맞지만 답은 아닐 수 있음. 배포가 더 자잘하다면 배포수준의 분리 등등 각 서비스마다 다를 것 같다고 생각. 초기 단계에 무엇을 고르냐는 답이 없을 것 같다고 생각. 고르라면 msa

  보형님 : 정현님 방식에 동의. 답이 없다는 것에도 동의. 작게 시작하면서 필요할 때 쪼개는게 맞다고 생각.

  어떤 단계를 고르는 것보다 리펙터링 시기를 확보하는게 중요


> 좋은 아키텍처는
- 이러한 변경으로 부터 소스 코드 대부분을 보호
- 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게끔 함
- 변경을 예측하여 큰 무리 없이 반영 할 수 있도록 만들어야 함
>